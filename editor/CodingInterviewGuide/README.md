程序员代码面试指南: IT名企算法与数据结构题目最优解
====

### 第1章 栈和队列
* [设计一个有getMin功能的栈（士★☆☆☆）](../cn/155.min-stack.h)
* [由两个栈组成的队列（尉★★☆☆） ](../cn/232.implement-queue-using-stacks.h)
* [如何仅用递归函数和栈操作逆序一个栈（尉★★☆☆）](CIG_1_1003.hpp)
* [猫狗队列（士★☆☆☆）](CIG_1_1004.hpp)
* [用一个栈实现另一个栈的排序（士★☆☆☆）](../cn/_03_05.sort-of-stacks-lcci.h)
* [用栈来求解汉诺塔问题（校★★★☆） ](../cn/_08_06.hanota-lcci.h)
* [生成窗口最大值数组（尉★★☆☆）](../cn/239.sliding-window-maximum.h)
* [构造数组的MaxTree（校★★★☆） ](../cn/654.maximum-binary-tree.h)
* [求最大子矩阵的大小（校★★★☆）]()
* [最大值减去最小值小于或等于num的子数组数量（校★★★☆） ]()

### 第2章 链表问题
* [打印两个有序链表的公共部分（士★☆☆☆）](CIG_1_2001.hpp)
* [在单链表中删除倒数第K 个节点（士★☆☆☆） ](../cn/19.remove-nth-node-from-end-of-list.h)
  * [在双链表中删除倒数第K 个节点](CIG_1_2003.hpp)
* [删除链表的中间节点（士★☆☆☆） ](CIG_1_2004.hpp)
  * [删除链表中a/b 处的节点](CIG_1_2005.hpp)
* [反转单向链表（士★☆☆☆）](../cn/206.reverse-linked-list.h)
  * [反转双向链表](CIG_1_2007.hpp)
* [反转部分单向链表（士★☆☆☆） ](../cn/92.reverse-linked-list-ii.h)
* [环形单链表的约瑟夫问题（原问题：士★☆☆☆ 进阶：校★★★☆）](CIG_1_2009.hpp)
* [判断一个链表是否为回文结构（普通解法士★☆☆☆）（进阶解法尉★★☆☆）](../cn/234.palindrome-linked-list.h)
* [将单向链表按某值划分成左边小、中间相等、右边大的形式（尉★★☆☆） ](CIG_1_2011.hpp)
* [复制含有随机指针节点的链表（尉★★☆☆）](../cn/138.copy-list-with-random-pointer.h)
* [两个单链表生成相加链表（士★☆☆☆） ](../cn/2.add-two-numbers.h)
* [两个单链表相交的一系列问题（将★★★★）](CIG_1_2014.hpp)
* [将单链表的每K个节点之间逆序（尉★★☆☆） ](../cn/25.reverse-nodes-in-k-group.h)
* [删除无序单链表中值重复出现的节点（士★☆☆☆）](CIG_1_2016.hpp)
* [在单链表中删除指定值的节点（士★☆☆☆） ](CIG_1_2017.hpp)
* [将搜索二叉树转换成双向链表（尉★★☆☆）](CIG_1_2018.hpp)
* [单链表的选择排序（士★☆☆☆） ](../cn/148.sort-list.h)
* [一种怪异的节点删除方式（士★☆☆☆）](../cn/237.delete-node-in-a-linked-list.h)
* [向有序的环形单链表中插入新节点（士★☆☆☆） ](CIG_1_2021.hpp)
* [合并两个有序的单链表（士★☆☆☆）](../cn/21.merge-two-sorted-lists.h)
* [按照左右半区的方式重新组合单链表（士★☆☆☆） ](CIG_1_2023.hpp)

### 第3章 二叉树问题
* [分别用递归和非递归方式实现二叉树先序遍历（校★★★☆）](../cn/144.binary-tree-preorder-traversal.h)
  * [分别用递归和非递归方式实现二叉树中序遍历](../cn/94.binary-tree-inorder-traversal.h)
  * [分别用递归和非递归方式实现二叉树后序遍历](../cn/145.binary-tree-postorder-traversal.h)
* [打印二叉树的边界节点: 标准一（尉★★☆☆） ]()
  * [打印二叉树的边界节点: 标准二]()
* [如何较为直观地打印二叉树（尉★★☆☆）]()
* [二叉树的序列化和反序列化（士★☆☆☆） ](../cn/297.serialize-and-deserialize-binary-tree.h)
* [遍历二叉树的神级方法（将★★★★）](CIG_1_3008.hpp)
* [在二叉树中找到累加和为指定值的最长路径长度（尉★★☆☆） ](CIG_1_3009.hpp)
* [找到二叉树中的最大搜索二叉子树（尉★★☆☆）](../cn/333.largest-bst-subtree.h)
* [找到二叉树中符合搜索二叉树条件的最大拓扑结构（校★★★☆）]()
* [二叉树的按层打印（尉★★☆☆）](../cn/102.binary-tree-level-order-traversal.h)
  * [二叉树的ZigZag打印](../cn/103.binary-tree-zigzag-level-order-traversal.h)
* [调整搜索二叉树中两个错误的节点（原问题：尉★★☆☆）（进阶问题：将★★★★） ](../cn/99.recover-binary-search-tree.h)
* [判断t1树是否包含t2 树全部的拓扑结构（士★☆☆☆） ](../cn/_26.shu-de-zi-jie-gou-lcof.h)
* [判断t1树中是否有与t2 树拓扑结构完全相同的子树（校★★★☆）](../cn/_04_10.check-subtree-lcci.h)
* [判断二叉树是否为平衡二叉树（士★☆☆☆）](../cn/110.balanced-binary-tree.h)
* [根据后序数组重建搜索二叉树（士★☆☆☆） ](CIG_1_3018.hpp)
* [判断一棵二叉树是否为搜索二叉树（士★☆☆☆）](../cn/98.validate-binary-search-tree.h)
  * [判断一棵二叉树是否为完全二叉树](../cn/958.check-completeness-of-a-binary-tree.h)
* [通过有序数组生成平衡搜索二叉树（士★☆☆☆） ](../cn/108.convert-sorted-array-to-binary-search-tree.h)
* [在二叉树中找到一个节点的后继节点（尉★★☆☆）](../cn/510.inorder-successor-in-bst-ii.h)
* [在二叉树中找到两个节点的最近公共祖先（原问题：士★☆☆☆）（进阶问题：尉★★☆☆）](../cn/236.lowest-common-ancestor-of-a-binary-tree.h)
* [Tarjan算法与并查集解决二叉树节点间最近公共祖先的批量查询问题（校★★★☆）]()
* [二叉树节点间的最大距离问题（尉★★☆☆） ](CIG_1_3025.hpp)
* [先序、中序和后序数组两两结合重构二叉树（先序与中序结合 士★☆☆☆）](../cn/105.construct-binary-tree-from-preorder-and-inorder-traversal.h)
  * [中序与后序结合 士★☆☆☆](../cn/106.construct-binary-tree-from-inorder-and-postorder-traversal.h)
  * [先序与后序结合 尉★★☆☆](../cn/889.construct-binary-tree-from-preorder-and-postorder-traversal.h)
* [通过先序和中序数组生成后序数组（士★☆☆☆）](CIG_1_3029.hpp)
* [统计所有不同的二叉树（尉★★☆☆） ](../cn/96.unique-binary-search-trees.h)
  * [生成所有不同的二叉树](../cn/95.unique-binary-search-trees-ii.h)
* [统计完全二叉树的节点数（尉★★☆☆）](../cn/222.count-complete-tree-nodes.h)

### 第4章 递归和动态规划
* [斐波那契系列问题的递归和动态规划（将★★★★） ](../cn/509.fibonacci-number.h)
* [矩阵的最小路径和（尉★★☆☆）](../cn/64.minimum-path-sum.h)
* [换钱的最少货币数（尉★★☆☆） ](../cn/322.coin-change.h)
  * [补充题目](CIG_1_4004.hpp)
* [换钱的方法数（尉★★☆☆）]()
* [最长递增子序列（校★★★☆） ]()
* [汉诺塔问题（校★★★☆）]()
* [最长公共子序列问题（尉★★☆☆） ]()
* [最长公共子串问题（校★★★☆）]()
* [最小编辑代价（校★★★☆） ]()
* [字符串的交错组成（校★★★☆）]()
* [龙与地下城游戏问题（尉★★☆☆） ]()
* [数字字符串转换为字母组合的种数（尉★★☆☆）]()
* [表达式得到期望结果的组成种数（校★★★☆） ]()
* [排成一条线的纸牌博弈问题（尉★★☆☆）]()
* [跳跃游戏（士★☆☆☆）]()
* [数组中的最长连续序列（尉★★☆☆）]()
* [N皇后问题（校★★★☆） ]()

### 第5章 字符串问题
* [判断两个字符串是否互为变形词（士★☆☆☆）](../cn/242.valid-anagram.h)
* [字符串中数字子串的求和（士★☆☆☆） ](CIG_1_5002.hpp)
* [去掉字符串中连续出现k 个0 的子串（士★☆☆☆） ](CIG_1_5003.hpp)
* [判断两个字符串是否互为旋转词（士★☆☆☆）](../cn/796.rotate-string.h)
* [将整数字符串转成整数值（尉★★☆☆） ](../cn/8.string-to-integer-atoi.h) 题目上略有不同，但核心是一样的
* [替换字符串中连续出现的指定字符串（士★☆☆☆）](CIG_1_5006.hpp)
* [字符串的统计字符串（士★☆☆☆） ](CIG_1_5007.hpp)
  * [补充题目](CIG_1_5008.hpp)
* [判断字符数组中是否所有的字符都只出现过一次（按要求1 实现的方法 士★☆☆☆）（按要求2 实现的方法 尉★★☆☆） ](CIG_1_5009.hpp)
* [在有序但含有空的数组中查找字符串（尉★★☆☆）](CIG_1_5010.hpp)
* [字符串的调整与替换（士★☆☆☆） ](../cn/_05.ti-huan-kong-ge-lcof.h)
  * [补充题目](CIG_1_5012.hpp)
* [翻转字符串（士★☆☆☆）](../cn/151.reverse-words-in-a-string.h)
  * [补充题目](../cn/_58_II.zuo-xuan-zhuan-zi-fu-chuan-lcof.h)
* [数组中两个字符串的最小距离（尉★★☆☆） ](../cn/_17_11.find-closest-lcci.h)
* [添加最少字符使字符串整体都是回文字符串（校★★★☆）](../cn/1312.minimum-insertion-steps-to-make-a-string-palindrome.h)
  * [补充题目](CIG_1_5017.hpp)
* [括号字符串的有效性（原问题 士★☆☆☆） ](CIG_1_5018.hpp)
  * [括号字符串的最长有效长度 尉★★☆☆](../cn/32.longest-valid-parentheses.h)
* [公式字符串求值（校★★★☆）]()
* [0 左边必有1 的二进制字符串数量（校★★★☆） ]()
* [拼接所有字符串产生字典顺序最小的大写字符串（校★★★☆）]()
* [找到字符串的最长无重复字符子串（尉★★☆☆）]()
* [找到被指的新类型字符（士★☆☆☆） ]()
* [最小包含子串的长度（校★★★☆）]()
* [回文最少分割数（尉★★★☆） ]()
* [字符串匹配问题（校★★★☆）]()
* [字典树（前缀树）的实现（尉★★☆☆） ]()

### 第6章 大数据和空间限制
* [认识布隆过滤器（尉★★☆☆）]()
* [只用2GB 内存在20 亿个整数中找到出现次数最多的数（士★☆☆☆） . ]()
* [40 亿个非负整数中找到没出现的数（尉★★☆☆） ]()
* [找到100 亿个URL 中重复的URL 以及搜索词汇的top K 问题（士★☆☆☆） ]()
* [40 亿个非负整数中找到出现两次的数和所有数的中位数（尉★★☆☆） ]()
* [一致性哈希算法的基本原理（尉★★☆☆）]()

### 第7章 位运算
* [不用额外变量交换两个整数的值（士★☆☆☆） ](../cn/_16_01.swap-numbers-lcci.h)
* [不用任何比较判断找出两个数中较大的数（校★★★☆）](../cn/_16_07.maximum-lcci.h)
* [只用位运算不用算术运算实现整数的加减乘除运算（尉★★☆☆） ](CIG_1_7003.hpp)
* [整数的二进制表达中有多少个1（尉★★☆☆）](../cn/191.number-of-1-bits.h)
* [在其他数都出现偶数次的数组中找到出现奇数次的数（尉★★☆☆） ](../cn/136.single-number.h)
  * [进阶问题](../cn/260.single-number-iii.h)
* [在其他数都出现k 次的数组中找到只出现一次的数（尉★★☆☆） ](../cn/137.single-number-ii.h)

### 第8章 数组和矩阵问题
* [转圈打印矩阵（士★☆☆☆）]()
* [将正方形矩阵顺时针转动90°（士★☆☆☆） ]()
* ["之"字形打印矩阵（士★☆☆☆）]()
* [找到无序数组中最小的k 个数（O(Nlogk)的方法尉★★☆☆）（O(N)的方法将★★★★） ]()
* [需要排序的最短子数组长度（士★☆☆☆）]()
* [在数组中找到出现次数大于N/K 的数（校★★★☆）]()
* [在行列都排好序的矩阵中找数（士★☆☆☆）]()
* [最长的可整合子数组的长度（尉★★☆☆） ]()
* [不重复打印排序数组中相加和为给定值的所有二元组和三元组（尉★★☆☆）]()
* [未排序正数数组中累加和为给定值的最长子数组长度（尉★★☆☆）]()
* [未排序数组中累加和为给定值的最长子数组系列问题（尉★★☆☆）]()
* [未排序数组中累加和小于或等于给定值的最长子数组长度（校★★★☆）]()
* [计算数组的小和（校★★★☆） ]()
* [自然数数组的排序（士★☆☆☆）]()
* [奇数下标都是奇数或者偶数下标都是偶数（士★☆☆☆）]()
* [子数组的最大累加和问题（士★☆☆☆）]()
* [子矩阵的最大累加和问题（尉★★☆☆） ]()
* [在数组中找到一个局部最小的位置（尉★★☆☆）]()
* [数组中子数组的最大累乘积（尉★★☆☆） ]()
* [打印N 个数组整体最大的Top K（尉★★☆☆） ]()
* [边界都是1 的最大正方形大小（尉★★☆☆） ]()
* [不包含本位置值的累乘数组（士★☆☆☆）]()
* [数组的partition 调整（士★☆☆☆） ]()
* [求最短通路值（尉★★☆☆）]()
* [数组中未出现的最小正整数（尉★★☆☆） ]()
* [数组排序之后相邻数的最大差值（尉★★☆☆）]()

### 第9章 其他题目
* [从5 随机到7 随机及其扩展（原问题尉★★☆☆补充问题尉★★☆☆）（进阶问题校★★★☆）]()
* [一行代码求两个数的最大公约数（士★★☆☆）]()
* [有关阶乘的两个问题（原问题尉★★☆☆进阶问题校★★★☆）]()
* [判断一个点是否在矩形内部（尉★★☆☆）]()
* [判断一个点是否在三角形内部（尉★★☆☆） ]()
* [折纸问题（尉★★☆☆）]()
* [蓄水池算法（尉★★☆☆）]()
* [设计有setAll功能的哈希表（士★☆☆☆） ]()
* [最大的leftMax与rightMax之差的绝对值（校★★★☆）]()
* [设计可以变更的缓存结构（尉★★☆☆）]()
* [设计RandomPool结构（尉★★☆☆） ]()
* [调整\[0,x)区间上的数出现的概率（士★☆☆☆）]()
* [路径数组变为统计数组（校★★★☆） ]()
* [正数数组的最小不可组成和（尉★★☆☆）]()
* [一种字符串和数字的对应关系（校★★★☆） ]()
* [1 到n 中1 出现的次数（校★★★☆） ]()
* [从N 个数中等概率打印M 个数（士★☆☆☆） ]()
* [判断一个数是否是回文数（士★☆☆☆）]()
* [在有序旋转数组中找到最小值（尉★★☆☆） ]()
* [在有序旋转数组中找到一个数（尉★★☆☆）]()
* [数字的英文表达和中文表达（校★★★☆） ]()
* [分糖果问题（校★★★☆）]()
* [一种消息接收并打印的结构设计（尉★★☆☆） ]()
* [设计一个没有扩容负担的堆结构（将★★★★）]()
* [随时找到数据流的中位数（将★★★★） ]()
* [在两个长度相等的排序数组中找到上中位数（尉★★☆☆）]()
* [在两个排序数组中找到第K 小的数（将★★★★） ]()
* [两个有序数组间相加和的TOP K 问题（尉★★☆☆）]()
* [出现次数的TOP K 问题（原问题尉★★☆☆进阶问题校★★★☆） ]()
* [Manacher算法（将★★★★）]()
* [KMP 算法（将★★★★） ]()
* [丢棋子问题（校★★★☆）]()
* [画匠问题（校★★★☆）]()
* [邮局选址问题（校★★★☆）]()
